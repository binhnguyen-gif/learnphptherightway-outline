00:00 - What are exceptions
###
"0:05 Chúng tôi đã trình bày cơ bản về xử lý lỗi 0:07 trong phần đầu tiên của khóa học này tại bài học 1.28 0:10 Trong bài học này, chúng tôi sẽ mở rộng về chủ đề đó và 0:12 nói về các ngoại lệ, đó là cách trong lập trình hướng đối tượng xử lý lỗi 0:17 Trước khi chúng ta bắt đầu, nếu bạn thích các bài học của tôi và chưa đăng ký theo dõi, vui lòng xem xét đăng ký để đảm bảo 0:22 rằng bạn không bỏ lỡ bất kỳ video mới nào 0:24 Vậy ngoại lệ là gì? Một ngoại lệ đơn giản là một đối tượng của một lớp ngoại lệ nào đó 0:29 mô tả một lỗi, nó làm gián đoạn luồng thực thi bình thường của mã 0:32 Trong PHP, ngoại lệ có thể được ném thủ công 0:36 bằng cách sử dụng từ khóa throw hoặc nó có thể là kết quả của một loại lỗi nào đó trong PHP 0:40 Cho dù đó là từ các hàm tích hợp sẵn trong PHP, các lớp hoặc từ mã của bạn. Bạn chỉ có thể ném ngoại lệ 0:46 nếu thể hiện của đối tượng được ném là hoặc là một lớp ngoại lệ hoặc là một thể hiện của giao diện Throwable 0:52 Hãy xem xét một ví dụ, tôi có lớp hóa đơn này cũng như lớp khách hàng 0:55 Lớp hóa đơn 0:57 sử dụng tính năng promotion thuộc tính trong hàm tạo, nó nhận đối tượng khách hàng 1:01 và có một phương thức duy nhất được gọi là process 1:03 chấp nhận một đối số là số tiền, sau đó chúng tôi đơn giản là mô phỏng việc xử lý hóa đơn 1:07 Đối tượng khách hàng 1:09 chính nó 1:10 có một thuộc tính được thúc đẩy gọi là billing info, sau đó chúng tôi có một phương thức getter cho thuộc tính billing info."

01:15 - Throwing exceptions
###
1:15 Ném ngoại lệ
Bây giờ, hãy xem xét trường hợp chúng ta không muốn cho phép việc xử lý hóa đơn nếu số tiền được cung cấp ít hơn hoặc bằng không 1:22 và có thể chúng ta cũng không muốn cho phép việc xử lý hóa đơn nếu khách hàng 1:26 thiếu thông tin thanh toán như địa chỉ thanh toán hoặc tên thanh toán. Đây là nơi mà việc ném ngoại lệ có thể hữu ích, mặc dù bạn có thể thêm kiểm tra ở mức độ cao hơn, có thể là trong controller hoặc nơi khác 1:37, luôn luôn là ý tưởng tốt để thực hiện nó ở mức độ thấp để bạn có thể chắc chắn rằng bất kỳ nơi nào phương thức xử lý được sử dụng, bạn không cho phép xử lý một số hóa đơn cụ thể 1:46 dựa trên điều kiện, vì vậy ở đây chúng ta có thể làm điều này giống như sau: nếu số tiền ít hơn hoặc bằng không 1:51 thì chúng ta có thể sử dụng từ khóa throw, sau đó là từ khóa new và chúng ta có thể ném một trong những ngoại lệ tích hợp sẵn, có một lớp ngoại lệ cơ bản gọi là ngoại lệ 2:00, vì vậy chúng ta có thể ném ngoại lệ đó trong lúc này, nó sẽ đơn giản là ném một ngoại lệ thông thường, hãy cung cấp một thông điệp thông thường như không hợp lệ về số tiền của hóa đơn 2:07. Tất nhiên, chúng ta không nên so sánh các số thực trực tiếp cho sự bằng nhau, nhưng cho ví dụ này, tôi sẽ giữ nó đơn giản và không thay đổi nó 2:16 và chỉ để nó như vậy, và chúng ta đã trình bày lý do tại sao bạn không nên so sánh số thực trực tiếp cho sự bằng nhau 2:21 trong phần đầu tiên của khóa học, trong bài học về kiểu dữ liệu số thực, vì vậy hãy chạy mã và kiểm tra điều này, cho đến nay mọi thứ đều hoạt động 2:28 vì chúng ta đang truyền vào số 25 2:31 là số tiền và nó không ít hơn hoặc bằng không, và do đó mọi thứ đều hoạt động bình thường, bây giờ hãy truyền vào số âm 25 và chạy mã lại và chắc chắn rằng chúng ta sẽ nhận được ngoại lệ này 2:41 được ném với thông điệp lỗi mà chúng ta đã chỉ định. Điều quan trọng là lớp ngoại lệ 2:44 ở đây rất chung chung, chúng ta có thể cụ thể hơn về ngoại lệ của chúng ta trước khi làm điều đó, hãy xem xét xem lớp ngoại lệ cung cấp gì 2:53, vì chúng ta có thông điệp mã tệp nơi lỗi xảy ra số dòng, nó chứa phương thức nhân, 3:00 được đặt là final có nghĩa là bạn không thể sao chép các đối tượng ngoại lệ, chúng ta có một constructor chấp nhận thông điệp mã lỗi và ngoại lệ trước đó cho phép chúng ta liên kết ngoại lệ với nhau, sau đó chúng ta cũng có một số phương thức final ở đây có nghĩa là bạn không thể ghi đè các phương thức này khi bạn mở rộng 3:16 lớp ngoại lệ. Nếu bạn cuộn xuống một chút nữa ở đây, chúng ta thấy lớp lỗi này thực hiện giao diện throwable. Nếu bạn cuộn lên lớp ngoại lệ, chúng ta thấy rằng nó cũng thực hiện giao diện drawable. 3:33. 3:32 Lúc này nếu tôi đề cập đến lớp ngoại lệ và lớp lỗi, cả hai lớp ngoại lệ và lớp lỗi đều là các loại ngoại lệ thực hiện giao diện drawable, 3:38 ngoại lệ là lớp cơ sở cho tất cả các ngoại lệ có thể bao gồm ngoại lệ được định nghĩa bởi người dùng, trong khi lớp lỗi là lớp cơ sở cho các ngoại lệ lỗi nội bộ của PHP. 3:47 Kể từ PHP 7, cả lớp ngoại lệ và lớp lỗi đều thực hiện giao diện drawable, cho phép chúng ta bắt cả hai ngoại lệ và lỗi 3:51 sử dụng giao diện throwable và chúng ta sẽ nói về
"3:51 điều này nhiều hơn trong vài phút nữa. Như tôi đã đề cập trước đó, PHP có một số ngoại lệ tích hợp sẵn, có thể cụ thể hơn, ví dụ chúng ta đang cố gắng ném một ngoại lệ vì đối số đã cho không hợp lệ, phải không? Ngẫu nhiên, PHP có một ngoại lệ tích hợp sẵn gọi là InvalidArgumentException, và nó hợp lý trong trường hợp này vì đối số đã cho không hợp lệ. Bây giờ nếu chúng ta chạy mã 4:14, nó vẫn ném một ngoại lệ, nhưng nó ném ngoại lệ InvalidArgumentException. 4:16 Nếu chúng ta nhấp vào đó, chúng ta thấy rằng nó chỉ là một lớp thông thường mà đơn giản là mở rộng LogicException. 4:18 và nếu chúng ta nhấp vào LogicException, đó chỉ là một lớp khác mà mở rộng Exception, vì vậy về cơ bản, tất cả các ngoại lệ đều dựa trên lớp Exception, trừ khi chúng là các ngoại lệ lỗi nội bộ của PHP

04:34 - Custom exceptions
###

07:15 - Catching exceptions (try/catch)
###

11:21 - Finally block & how return statements work from try, catch & finally blocks
###

14:12 - Global exception handler, error hierarchy & changes in error reporting in PHP 7 & PHP 8
###


17:50 - When to use exceptions
###


18:49 - Domain-specific exception class with static methods to throw specific exceptions