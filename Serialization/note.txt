00:00 - Serialization
###
"0:05 Serialization, đơn giản là quá trình chuyển đổi một giá trị thành dạng chuỗi. Bạn có thể serialize hầu hết các giá trị có thể lưu trữ trong PHP, bao gồm cả các đối tượng, nhưng bạn không thể serialize các loại resource hoặc closures, cũng như một số đối tượng tích hợp trong PHP.
0:20 Ví dụ, hãy serialize một số giá trị và xem chúng trông như thế nào. Chúng ta sẽ hiển thị giá trị của hàm serialize và sẽ serialize giá trị boolean true, integer, float, một số chuỗi, một số mảng, và một số mảng kết hợp. Chạy mã và bạn sẽ thấy chúng ta nhận được chuỗi biểu diễn của những giá trị đó.
0:45 Sau khi một giá trị được serialize, chúng ta có thể sử dụng hàm unserialize để chuyển chuỗi trở lại thành dạng gốc của nó. Dưới đây là ví dụ về việc unserialize một mảng sau khi đã serialize. Chạy mã và bạn sẽ thấy chúng ta nhận được lại mảng ban đầu.
1:04 Serialization có thể hữu ích để truyền giá trị PHP hoặc lưu trữ chúng để sử dụng sau này, ví dụ như trong cơ sở dữ liệu hoặc nơi lưu trữ khác."

01:12 - Serializing objects
###
"0:12 Khi bạn serialize đối tượng, nó sẽ serialize các thuộc tính và giá trị của nó, cũng như tên lớp (class name), nhưng nó sẽ không serialize các phương thức (methods). Vì vậy, nếu bạn serialize một đối tượng của một lớp và lưu trữ nó ở đâu đó, chẳng hạn trong cơ sở dữ liệu hoặc một nơi khác để sử dụng sau này, bạn cần đảm bảo rằng định nghĩa lớp (class definition) tồn tại cũng như các phương thức mà nó cần. Khi bạn thực sự unserialize (giải mã) chuỗi đó, nếu không, bạn sẽ gặp lỗi.
1:38 Ví dụ, hãy serialize đối tượng invoice ở đây và xem chúng ta nhận được gì. Chúng ta nhận được biểu diễn dạng chuỗi của đối tượng. Lưu ý rằng tên lớp được thêm vào trước tên thuộc tính ở đây. Điều này xảy ra vì thuộc tính được đặt là private và các thuộc tính private sẽ có tên lớp được thêm vào trước.
1:56 Nếu chúng ta thay đổi thuộc tính từ private thành protected, thay vì tên lớp, nó sẽ được thêm dấu asterisk. Chạy mã lại và chúng ta thấy rằng nó được thêm dấu asterisk.
2:00 Nếu chúng ta thay đổi thành public, thì không có gì được thêm vào. Chúng ta có thể unserialize (giải mã) giá trị này trực tiếp, chẳng hạn nếu chúng ta lưu trữ nó ở đâu đó, như trong cơ sở dữ liệu, sau đó muốn giải mã nó. Chỉ cần thử unserialize giá trị đó và sử dụng var_dump để xem nó trông như thế nào. Xóa bỏ dữ liệu và chạy mã, chúng ta thấy chúng ta nhận được đối tượng với ID đúng, đã được lưu ở đây.
3:26 Lưu ý rằng khi bạn unserialize (giải mã) một đối tượng, thực tế là tạo ra một đối tượng mới, điều này có nghĩa là nó sẽ không trỏ vào cùng một vị trí trong bộ nhớ như đối tượng gốc.
3:58 Ví dụ, thay vì làm như vậy, hãy thử serialize đối tượng invoice lại và sau đó unserialize nó thành một biến khác gọi là invoice2 và sử dụng var_dump cho cả invoice và invoice2, cùng so sánh invoice và invoice2 sử dụng toán tử đồng nhất (identity operator). Xóa dữ liệu và chạy mã, chúng ta thấy rằng, mặc dù các thuộc tính và giá trị giống nhau, ID của invoice là giống nhau cho cả invoice gốc và invoice sau khi unserialize. Tuy nhiên, đối tượng invoice thực sự là khác nhau. Đây là số 3, đây là số 2, và toán tử đồng nhất trả về false. Nếu bạn so sánh bằng toán tử so sánh (double equal sign) thì nó sẽ trả về true, và nó trả về true vì các giá trị thuộc tính giống nhau, nhưng đây là hai đối tượng khác nhau.
3:39 Như bạn thấy, chúng ta đã khám phá một cách khác để tạo ra một đối tượng mới hoặc sao chép một đối tượng. Từ khóa clone, mà chúng ta đã bàn luận trong bài học trước để tạo ra các bản sao của đối tượng, thực hiện sao chép nông (shallow copying), trong khi việc tạo ra các đối tượng bằng cách sử dụng serialize và unserialize thực hiện sao chép sâu (deep copying). Do đó, bạn có thể thấy các hàm serialize và unserialize được sử dụng để thực hiện sao chép sâu hoặc sao chép đối tượng, mặc dù điều này không phải lúc nào cũng phổ biến, và nếu có nhu cầu đủ lớn, tôi có thể tạo một bài học riêng về sao chép nông và sao chép sâu.
4:04 Cuối cùng, hãy lưu ý rằng bạn không nên bao giờ truyền dữ liệu không đáng tin cậy vào hàm unserialize. Điều này có thể bị khai thác và mã không mong muốn có thể được tải và thực thi khi đối tượng được khởi tạo lại trong quá trình unserialize."

04:07 - Serializing boolean false & return false on failed unserialization
###
"4:07 Khi serialize giá trị boolean false và quá trình unserialize không thành công vì bất kỳ lý do gì, nó sẽ trả về giá trị false và gây ra một thông báo lỗi (notice error). Ví dụ, nếu chúng ta cố gắng unserialize chuỗi này một lần nữa và sau đó sử dụng var_dump, nó hoạt động đúng. Nhưng nếu chúng ta mắc lỗi hoặc có thể chuỗi bị hỏng, có thể nó là một chuỗi không hợp lệ hoặc có vấn đề gì đó, chẳng hạn nếu chúng ta xóa dấu ngoặc đơn từ đây và chạy mã, chúng ta sẽ nhận thông báo lỗi và nó sẽ trả về giá trị boolean false.
4:39 Điều quan trọng cần lưu ý ở đây là khi bạn serialize giá trị boolean false thực sự, khi bạn unserialize nó, cũng sẽ trả về giá trị false. Điều này có thể gây ra một số vấn đề, ví dụ, hãy xem xét trường hợp chúng ta có chuỗi bằng với serialize false và sau đó chúng ta xóa đi phần này và xóa mã lệnh, chúng ta thấy rằng nó trả về giá trị boolean false. Vì vậy, trong trường hợp này, bạn không chắc chắn liệu quá trình unserialize có thất bại hay thành công. Để giải quyết vấn đề này, bạn có thể so sánh chuỗi với giá trị serialized false và nếu chúng bằng nhau thì mọi thứ đều ổn. Một cách khác để giải quyết vấn đề này là sử dụng xử lý lỗi (error handling) để bắt lỗi e-notice và sau đó xử lý nó một cách cụ thể."

05:11 - Magic methods intro & Serializable interface
###
"5:11 Được rồi, chúng ta tiến xa hơn và nói về các phương thức kỳ diệu liên quan đến serialization. Giả sử rằng chúng ta muốn thay đổi cách đối tượng được serialize hoặc unserialize. Ví dụ, hãy nói rằng trong lớp Invoice, chúng ta có nhiều thuộc tính như amount (số tiền), description (mô tả) và có thể số thẻ tín dụng (credit card number). Bây giờ, trong một số trường hợp, có lẽ bạn không muốn serialize số thẻ tín dụng khi bạn serialize đối tượng hoặc hóa đơn. Có thể bạn muốn mã hóa nó và sau khi unserialize, bạn muốn giải mã nó. Có một số cách chúng ta có thể làm điều đó. Một cách là đơn giản là triển khai giao diện Serializable và sau đó triển khai các phương thức serialized và unserialize. Tuy nhiên, giao diện Serializable sẽ bị loại bỏ trong PHP 8.1 và sẽ được gỡ bỏ hoàn toàn trong PHP 9, vì vậy tôi sẽ không đi vào chi tiết nhiều về cách hoạt động này vì nó sẽ không còn quan trọng sau này. Thay vào đó, chúng ta sẽ nói về các phương thức kỳ diệu (magic methods) có thể được sử dụng để đạt được điều tương tự mà giao diện này đã cung cấp. Hãy loại bỏ giao diện Serializable cũng như các phương thức liên quan và chúng ta sẽ sắp xếp các thuộc tính này để có thể chấp nhận đối số trong constructor. Chúng ta có bốn phương thức kỳ diệu liên quan đến serialization, đó là __sleep, __wakeup, serialize, và unserialize. Hãy nói về phương thức __sleep và"

06:21 - __sleep & __wakeup magic methods
###
Phương thức ma thuật __sleep và __wakeup
Trước hết, phương thức ma thuật __sleep được gọi trước khi quá trình tuần tự hóa diễn ra và phương thức __wakeup được gọi sau khi đối tượng đã được khôi phục từ quá trình tuần tự hóa. Phương thức __sleep có thể được sử dụng để kết nối vào sự kiện trước khi tuần tự hóa để thực hiện một số công việc dọn dẹp. Bạn có thể chỉ định chính xác các thuộc tính bạn muốn tuần tự hóa bằng cách trả về một mảng chứa tên của các thuộc tính đó. Ví dụ, nếu bạn chỉ muốn tuần tự hóa id và amount, bạn chỉ cần trả về một mảng chứa tên của các thuộc tính đó: id và amount. Khi đối tượng được tuần tự hóa, chỉ có những thuộc tính đó mới được tuần tự hóa.
Như đã đề cập trước, khi tuần tự hóa đối tượng, nó sẽ không tuần tự hóa bất kỳ tài nguyên nào như kết nối cơ sở dữ liệu mở hoặc một cái gì đó tương tự. Hoặc có thể bạn có một đối tượng phức tạp có nhiều phụ thuộc, trong trường hợp đó, phương thức ma thuật __wakeup có thể được sử dụng để khôi phục các kết nối và tài nguyên đó khi đối tượng được khôi phục từ quá trình tuần tự hóa, những thứ này có thể đã bị mất trong quá trình tuần tự hóa. Hãy thử nghiệm điều này, chúng ta quay lại tệp index.php và truyền vào một số giá trị trong hàm tạo. Ví dụ, chúng ta sẽ truyền số lượng là 25, mô tả là "invoice 1" và một số thẻ tín dụng giả mạo. Sau đó, chúng ta tuần tự hóa hóa đơn và lưu trữ nó trong một biến, sau đó hiển thị nó ra màn hình. Chúng ta thấy rằng chỉ có id và amount được tuần tự hóa và không có gì khác. Rất tuyệt vời, phải không? Tiếp theo, chúng ta sẽ thảo luận về serialize và...

07:44 - __serialize & __unserialize magic methods
###
Phương thức ma thuật __serialize và __unserialize 7:45 là hai phương thức ma thuật đã được thêm vào PHP 7.4 7:47. Các phương thức ma thuật __serialize và __unserialize giải quyết một số hạn chế và vấn đề liên quan đến phương thức ma thuật __sleep và __wakeup, cũng như giao diện Serializable 7:51. Bạn có thể xem phương thức ma thuật __serialize và __unserialize như một sự kết hợp của phương thức ma thuật __sleep, __wakeup, và giao diện Serializable 8:05.
Phương thức ma thuật __serialize được gọi trước khi đối tượng được serialize, tương tự như phương thức ma thuật __sleep và cũng trả về một mảng. Sự khác biệt giữa phương thức __sleep và __serialize là phương thức __sleep phải trả về tên của các thuộc tính cần được serialize, trong khi phương thức __serialize phải trả về một mảng biểu diễn đối tượng và có thể là một mảng kết hợp của các cặp key-value và có thể chứa thông tin bổ sung khác ngoài các thuộc tính hiện tại. Vì vậy, bạn không bị giới hạn chỉ đối với các thuộc tính như trong phương thức __sleep, mà bạn có toàn quyền kiểm soát cách đối tượng của bạn được serialize. Ví dụ, bạn có thể trả về các thuộc tính bạn muốn serialize cũng như mã hóa số thẻ tín dụng. Trong ví dụ này, chúng ta sẽ trả về một mảng gồm các thuộc tính id, amount, description và số thẻ tín dụng được mã hóa base64.
Phương thức ma thuật __sleep không bị xóa, nhưng khi bạn có cả phương thức ma thuật __sleep và __serialize, phương thức __serialize sẽ được thực thi trước và phương thức __sleep sẽ bị bỏ qua.
Tương tự, phương thức ma thuật __unserialize được gọi sau khi đối tượng đã được unserialize, giống như phương thức ma thuật __wakeup. Sự khác biệt giữa hai phương thức này là phương thức __unserialize nhận dữ liệu đã được serialize như đối số, cho phép bạn khôi phục trạng thái của đối tượng sử dụng dữ liệu đó. Bạn có thể khôi phục lại các thuộc tính, kết nối hoặc thực hiện bất kỳ công việc nào cần thiết để xây dựng lại đối tượng.
Hãy sử dụng var_dump để hiển thị dữ liệu ở đây và thử unserialize đối tượng trong tệp index.php. Chúng ta sẽ unserialize nó thành invoice2. Hãy tạm thời ghi chú phần này và chạy mã để xem dữ liệu được hiển thị. Bạn sẽ thấy chúng ta nhận được dữ liệu đã được serialize trước đây.
Bây giờ chúng ta có thể sử dụng dữ liệu này để tái khôi phục đối tượng của chúng ta và khôi phục lại bất kỳ thuộc tính nào hoặc thực hiện bất kỳ kết nối hoặc giá trị thuộc tính nào cần thiết. Ví dụ, chúng ta có thể khôi phục lại các thuộc tính bằng cách sử dụng dữ liệu này và giải mã số thẻ tín dụng được mã hóa base64. Đối với các dữ liệu bổ sung mà chúng ta không có thuộc tính tương ứng, chúng ta có thể thực hiện bất kỳ công việc nào cần thiết, ví dụ như tính toán hoặc tạo ra các thuộc tính ảo.
Cuối cùng, hãy quay lại tệp index.php và sử dụng var_dump đơn giản cho invoice2. Chạy mã và bạn sẽ thấy chúng ta nhận được đối tượng được xây dựng đúng cách và số thẻ tín dụng không còn được mã hóa nữa.
Đó là tất cả về bài giảng này. Hy vọng bài học này hữu ích đối với bạn. Cảm ơn bạn đã xem video này. Nếu bạn thích nó, hãy bấm like và chia sẻ. Đừng quên đăng ký kênh và chúng ta sẽ gặp lại bạn trong các bài học tiếp theo.

